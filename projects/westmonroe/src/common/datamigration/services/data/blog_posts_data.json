[
{
	"title": "Blog Post 1",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}
	]
},
{
	"title": "Blog Post 2",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 3",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 4",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 5",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 6",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 7",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 8",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 9",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 10",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 11",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 12",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 13",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 14",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 15",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 16",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 17",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 18",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 19",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 20",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 21",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 22",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 23",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 24",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 25",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 26",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 27",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 28",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 29",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 30",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 31",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 32",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 33",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 34",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 35",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 36",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 37",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 38",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 39",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 40",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 41",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 42",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 43",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 44",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 45",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 46",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 47",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 48",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 49",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
},
{
	"title": "Blog Post 50",
	"posted_on": "2024-04-30",
	"author_name": "Bartee Natarajan",
	"read_time": "4-MINUTE READ",
	"body": "<p>In our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>, we described how parallel programming can be exploited to accomplish complex tasks using the “divide-and-conquer” paradigm. In this article, we’ll talk about a unique problem, the “Race Condition,” that can happen in parallel programming contexts that is difficult to troubleshoot but can be avoided with proper planning. You will see that an innocuous fragment of code can cause unexpected consequences.&nbsp;&nbsp;</p><h2>The plot</h2><p>We are building a financial services application in which customers apply for loans (e.g., a small business loan). These loans can be automatically renewed at the end of their term with potential changes to rates, terms, and conditions. On a monthly basis, we are handed a set of prefetched loan records that are ready to renew. Our requirement is to build an automated loan renewal workflow.&nbsp;\n\n<br/>A critical stage in this workflow is requesting a fresh credit report for the loan applicants. The code fragment below illustrates these steps:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(387).png\" width=\"100\"/><p>Figure 1 – Request Credit Report code fragment</p><p>In the code, we construct a request per applicant and fetch the report from a managed package service (line 13) that handles communication with different credit agencies (e.g., Experian, TransUnion etc.). The service fetches the credit report asynchronously and returns a transaction id in the response that we can use to track our request status. We store this under each loan (line 19).&nbsp;\n\n<br/>When the credit report is eventually received per applicant, the report is stored in the database by a different program flow (thread). We piggy-back on this write-back (via a simple after-update trigger) to link the newly fetched report with the loans for that applicant. This is shown in the code fragment below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(388).png\" width=\"100\"/><p>Figure 2 – Store Credit Report code fragment</p><h2>The mystery</h2><p>During our tests, we found that the new credit report is not stored consistently in our loans. Sometimes they show up; sometimes they don’t. There were no errors in any of the logs; we verified that the new credit report was fetched and stored properly. We even verified that our trigger code was executing successfully! Still, there was no new credit report being attached to these loans. How can this be?</p><h2>The culprit</h2><p>After pulling hairs for a bit, we realized that we have been burnt by a “race condition,” a problem when the order of execution between parallel threads (the “race”) causes unpredictable outcomes. An illustration of the scenario is shown below:</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-3.png\" width=\"100\"/><p>Figure 3 – Race condition illustration</p><p>Unbeknownst to us, a race had started as soon as we made a request to fetch credit reports. There are two threads of execution. The blue thread that made the request and the green thread that stores the received credit report. We might anticipate that the blue thread has far less to do and will most likely complete first. But there are factors within and outside our control (e.g., network latency, resource caching, database automations, etc.) that can decide which thread wins the race each time. If the green thread unexpectedly completes before the blue thread, we store the transaction log id on the loan<span>&nbsp;</span><em>after</em><span>&nbsp;</span>the credit report is saved.&nbsp;\n\n<br/>You might ask: Why is this relevant? Aren’t they updating different fields on the loan? Well, it so happens that when the loans were handed to us for renewal, the current credit report was also fetched from the database on the loan<span>&nbsp;</span><em>sObject</em>. So, when we update the loans in the blue thread (Figure 1: line 22), we were inadvertently setting the transaction log id<span>&nbsp;</span><em>and the credit report</em>. The&nbsp;order of operation is illustrated below.</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/race-condition-illustration---figure-4.png\" width=\"100\"/><p>Figure 4 – Out of Order!</p><p>We set the new credit report properly on the loan (green thread) and promptly revert it back (blue thread with the red outline)!\n\n<br/>A “race condition” rears its head when all three of these circumstances are in play:</p><ol><li><p>There are parallel threads of execution (in our case, the blue and green threads)</p></li><li><p>At least one shared resource is being manipulated in those threads (in our case, the renewal loan)</p></li><li><p>A programming assumption (read: “mistake”) is expecting a particular order of finish (in our case, we expect blue thread to complete before green)</p></li></ol><h2>The solution</h2><p>Awareness is the first step to resolving race conditions. Understanding when a parallel programming context is triggered can help you focus on shared resource updates.&nbsp;\n\n<br/>They are particularly difficult to troubleshoot because there are no immediate failures, only unexpected behaviors.&nbsp;\n\n<br/>Once we understand what’s happening, the solution is simple. We cannot avoid the race, but we can ensure that the race avoids affecting us. We should limit our update in the blue thread to only the transaction log id, making the order of finish irrelevant. The updated code fragment is shown below (line 21 in bold).</p><img src=\"https://cdn.westmonroe.com/-/media/west-monroe-images/perspective-images/blog/screenshot-(389).png\" width=\"100\"/><p>Figure 5 – Solution to the Race Condition</p><p>We could also solve it by guaranteeing order using “join” techniques discussed in our<span>&nbsp;</span><a href=\"https://www.westmonroe.com/perspectives/the-conduit-blog/parallel-programming-using-the-fork-Join-model-in-salesforce\">Fork-Join article</a>. That would be needlessly complex and inefficient in this case, but a different scenario might require it.&nbsp;</p><h2>Final thoughts</h2><p>Race conditions are a classic byproduct of programming assumptions that (wrongly) anticipate and depend on a particular order of finish in parallel contexts when the order is not guaranteed. They are difficult to troubleshoot because they don’t always fail. They only get harder when we don’t know that a race is happening. For instance, in our example, the race was created by a managed package service that we did not have visibility into. Awareness of the problem can help us resolve them safely. Happy coding!</p>",
	"author": [
		{
			"uid": "blt56626e92b677cc67",
			"_content_type_uid": "author"
		}
	],
	"tags": [],
	"locale": "en-us",
	"uid": "blt144cb1e3ec8f1b89",
	"created_by": "cs39616b95364d99be",
	"updated_by": "cs39616b95364d99be",
	"created_at": "2024-04-30T15:06:57.238Z",
	"updated_at": "2024-04-30T15:08:20.038Z",
	"_version": 2,
	"_in_progress": false,
	"category": [
		{
			"uid": "blt33b499068a76a50b",
			"_content_type_uid": "blog_category"
		}

  ]
}
]
